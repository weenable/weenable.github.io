<!DOCTYPE html>
<html lang="en-us"
  dir="ltr">

<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width">



<link rel="icon" type="image/ico" href="https://weenable.github.io//favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://weenable.github.io//favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://weenable.github.io//favicon-32x32.png">
<link rel="icon" type="image/png" sizes="192x192" href="https://weenable.github.io//android-chrome-192x192.png">
<link rel="apple-touch-icon" sizes="180x180" href="https://weenable.github.io//apple-touch-icon.png">

<link rel="alternate" type="application/rss+xml" href="https://weenable.github.io/categories/golang/index.xml" title="Ween's Blog">
<meta name="description" content=""/>



<title>
    
    Golang | Ween&#39;s Blog
    
</title>

<link rel="canonical" href="https://weenable.github.io/categories/golang/"/>

<meta property="og:url" content="https://weenable.github.io/categories/golang/">
  <meta property="og:site_name" content="Ween&#39;s Blog">
  <meta property="og:title" content="Golang">
  <meta property="og:description" content="Ween&#39;s Blog">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="website">








<link rel="stylesheet" href="/assets/combined.min.db1f6bdda2e5a4d5c9a316aa295aaeba691b0d6154397bbb6787fea95b273e6a.css" media="all">









</head>





<body class="auto">

  <div class="content">
    <header>
      

<div class="header">

    

    <h1 class="header-title">
        <a href="https://weenable.github.io/">Ween&#39;s Blog</a>
    </h1>

    <div class="flex">
        

        
        
      
        <p class="small ">
            <a href="/" >
                /home
            </a>
        </p>
        
      
        <p class="small ">
            <a href="/posts" >
                /posts
            </a>
        </p>
        
      
        <p class="small ">
            <a href="/categories" >
                /categories
            </a>
        </p>
        
        
    </div>

    

</div>

    </header>

    <main class="main">
      

<div class="list-container">

    

    <h1>Golang</h1>
    

    

    
    
    
    

    

    

    
    <div class="post-line">

    
    
    
    

    <p class="line-date">2025-02-28 </p>

    <div>
        <p class="line-title">
            <a href="/posts/game/%E6%B8%B8%E6%88%8F%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B/">
                游戏服务器架构演进
            </a>
        </p>

        
        <p class="line-summary"> <h3 class="heading" id="游戏服务器要素">
  游戏服务器要素
  <a class="anchor" href="#%e6%b8%b8%e6%88%8f%e6%9c%8d%e5%8a%a1%e5%99%a8%e8%a6%81%e7%b4%a0">#</a>
</h3>
<p>对于游戏服务器，三个比较重要的部份就是：CPU、内存、带宽的设计</p>
<ul>
<li>逻辑架构：合适的进程、线程、协程的CPU调度方案，合适的同步或异步编程模型，分区分服或世界服的方式来提高服务器的承载量和稳定性</li>
<li>内存架构：合理使用内存，提高承载量，降低服务延迟</li>
<li>通信架构：通信协议如UDP/TCP</li>
</ul>
<h3 class="heading" id="游戏服务器演进">
  游戏服务器演进
  <a class="anchor" href="#%e6%b8%b8%e6%88%8f%e6%9c%8d%e5%8a%a1%e5%99%a8%e6%bc%94%e8%bf%9b">#</a>
</h3>
<h4 class="heading" id="一弱交互游戏服务器">
  一、弱交互游戏服务器
  <a class="anchor" href="#%e4%b8%80%e5%bc%b1%e4%ba%a4%e4%ba%92%e6%b8%b8%e6%88%8f%e6%9c%8d%e5%8a%a1%e5%99%a8">#</a>
</h4>
<p>基于http通信模式的服务器，服务器架构和web差不多</p>
<p>











<figure class="">

    <div>
        <img loading="lazy" alt="image-2025228214121.png" src="images/%E6%B8%B8%E6%88%8F%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B/image-2025228214121.png" >
    </div>

    
</figure>
</p>
<h4 class="heading" id="二长连接游戏服务器">
  二、长连接游戏服务器
  <a class="anchor" href="#%e4%ba%8c%e9%95%bf%e8%bf%9e%e6%8e%a5%e6%b8%b8%e6%88%8f%e6%9c%8d%e5%8a%a1%e5%99%a8">#</a>
</h4>
<p>在长连接中玩家是有状态的，消息传送的频率以及速度都快于弱联网游戏</p>
<h5 class="heading" id="第一代游戏服务器单线程无阻塞">
  第一代游戏服务器，单线程无阻塞
  <a class="anchor" href="#%e7%ac%ac%e4%b8%80%e4%bb%a3%e6%b8%b8%e6%88%8f%e6%9c%8d%e5%8a%a1%e5%99%a8%e5%8d%95%e7%ba%bf%e7%a8%8b%e6%97%a0%e9%98%bb%e5%a1%9e">#</a>
</h5>
<p>所有玩家的请求都发到一个无阻塞的消息队列中，由单线程处理消息</p>
<p>











<figure class="">

    <div>
        <img loading="lazy" alt="image-20252282212369.png" src="images/%E6%B8%B8%E6%88%8F%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B/image-20252282212369.png" >
    </div>

    
</figure>
</p>
<p>线程模型如下：</p>
<p>











<figure class="">

    <div>
        <img loading="lazy" alt="image-20252282223840.png" src="images/%E6%B8%B8%E6%88%8F%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B/image-20252282223840.png" >
    </div>

    
</figure>
</p>
<h5 class="heading" id="第二代游戏服务器分区分服">
  第二代游戏服务器，分区分服
  <a class="anchor" href="#%e7%ac%ac%e4%ba%8c%e4%bb%a3%e6%b8%b8%e6%88%8f%e6%9c%8d%e5%8a%a1%e5%99%a8%e5%88%86%e5%8c%ba%e5%88%86%e6%9c%8d">#</a>
</h5>
<p>单游戏服务器承载用户客户端有限，于是出现分区分服的概念，这种模型中一个游戏服务器就是一个平行世界，在第二代游戏服务器中同时也对进程和线程模型做了升级</p>
<ul>
<li>多线程：每个线程处理一个特定的场景内的tick事件，如果玩家跨场景则通过消息投递的方式通知另一个场景线程来进行玩家数据同步</li>
<li>多进程：将网络、数据库的操作单独使用进程来处理，逻辑进程专心处理逻辑任务</li>
</ul>
<p>











<figure class="">

    <div>
        <img loading="lazy" alt="image-20252282244672.png" src="images/%E6%B8%B8%E6%88%8F%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B/image-20252282244672.png" >
    </div>

    
</figure>
</p>
<h5 class="heading" id="第三代游戏服务器世界服">
  第三代游戏服务器，世界服
  <a class="anchor" href="#%e7%ac%ac%e4%b8%89%e4%bb%a3%e6%b8%b8%e6%88%8f%e6%9c%8d%e5%8a%a1%e5%99%a8%e4%b8%96%e7%95%8c%e6%9c%8d">#</a>
</h5>
<p>第三代游戏服务器主要是世界服，分为以下几种演化</p>
<ul>
<li>三层架构：包含网关服务器、游戏逻辑服务器、DB服务器</li>
</ul>
<p>











<figure class="">

    <div>
        <img loading="lazy" alt="image-20252282257901.png" src="images/%E6%B8%B8%E6%88%8F%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B/image-20252282257901.png" >
    </div>

    
</figure>
</p>
<ul>
<li>分片架构：将游戏逻辑服务器再进行分片，分离出如场景服务器、非场景服务器等</li>
</ul>
<p>











<figure class="">

    <div>
        <img loading="lazy" alt="image-20252282311243.png" src="images/%E6%B8%B8%E6%88%8F%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B/image-20252282311243.png" >
    </div>

    
</figure>
</p>
<ul>
<li>大世界架构：将世界按区块划分，各场景服务器管理不同区块</li>
</ul>
<h4 class="heading" id="三房间服务器游戏大厅">
  三、房间服务器，游戏大厅
  <a class="anchor" href="#%e4%b8%89%e6%88%bf%e9%97%b4%e6%9c%8d%e5%8a%a1%e5%99%a8%e6%b8%b8%e6%88%8f%e5%a4%a7%e5%8e%85">#</a>
</h4>
<p>主要分为大厅服务器、匹配服务器、对战服务器</p>
<p>











<figure class="">

    <div>
        <img loading="lazy" alt="image-20252282323894.png" src="images/%E6%B8%B8%E6%88%8F%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B/image-20252282323894.png" >
    </div>

    
</figure>
</p> </p>
        
    </div>
</div>
    

    

    
    <div class="post-line">

    
    
    
    

    <p class="line-date">2025-02-28 </p>

    <div>
        <p class="line-title">
            <a href="/posts/golang/go-redis%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%E4%B8%BB%E4%BB%8E%E5%88%87%E6%8D%A2%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">
                go-redis哨兵模式主从切换源码分析
            </a>
        </p>

        
        <p class="line-summary"> <h5 class="heading" id="实现原理">
  实现原理
  <a class="anchor" href="#%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86">#</a>
</h5>
<ol>
<li>通过哨兵获取主节点信息：在连接 Redis 集群时，<code>go-redis</code> 客户端会连接到一个或多个哨兵节点，获取当前的主节点信息。如果主节点发生故障，哨兵会进行故障转移，并通知客户端新的主节点信息。</li>
<li>周期性地从哨兵获取主节点信息：<code>go-redis</code> 客户端会周期性地向哨兵节点请求主节点信息，以确保它始终连接到当前的主节点。这个机制可以帮助客户端快速感知主从切换。</li>
<li>在操作失败时重新获取主节点信息：如果客户端在执行操作时遇到连接错误或其他错误，可能会重新从哨兵节点获取主节点的信息，并重试操作。</li>
</ol>
<h5 class="heading" id="源码分析">
  源码分析
  <a class="anchor" href="#%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90">#</a>
</h5>
<ul>
<li>初始化</li>
</ul>
<pre tabindex="0"><code>//rdb := redis.NewFailoverClient(&amp;redis.FailoverOptions{
//    MasterName:    &#34;mymaster&#34;, // 哨兵配置中主节点的名字
//    SentinelAddrs: []string{&#34;127.0.0.1:26379&#34;, &#34;127.0.0.1:26380&#34;, &#34;127.0.0.1:26381&#34;},
//})


type FailoverOptions struct {
    MasterName    string
    SentinelAddrs []string
    // ... other options
}

func NewFailoverClient(opt *FailoverOptions) *Client {
    sentinel := newSentinel(opt)
    return NewClient(&amp;Options{
        Addr: sentinel.masterAddr(),
        // ... other options
    })
}

func newSentinel(opt *FailoverOptions) *sentinel {
    // Connect to sentinel nodes and get master address
    return &amp;sentinel{
        masterName: opt.MasterName,
        addrs:      opt.SentinelAddrs,
    }
}

func (s *sentinel) masterAddr() string {
    // Get master address from sentinel nodes
}
</code></pre><ul>
<li>周期性刷新master地址</li>
</ul>
<pre tabindex="0"><code>func (s *sentinel) periodicallyRefreshMasterAddr() {
    ticker := time.NewTicker(time.Minute)
    for range ticker.C {
        addr := s.masterAddr()
        // Update client&#39;s master address
    }
}
</code></pre><ul>
<li>失败时重试和刷新master</li>
</ul>
<pre tabindex="0"><code>func (c *Client) doWithRetry(fn func() error) error {
    for i := 0; i &lt; maxRetries; i++ {
        err := fn()
        if err == nil {
            return nil
        }
        if isConnectionError(err) {
            c.refreshMasterAddr()
        }
        time.Sleep(retryBackoff)
    }
    return fmt.Errorf(&#34;after %d retries, last error: %v&#34;, maxRetries, err)
}

func (c *Client) refreshMasterAddr() {
    addr := c.sentinel.masterAddr()
    c.Options().Addr = addr
}
</code></pre> </p>
        
    </div>
</div>
    

    

    
    <div class="post-line">

    
    
    
    

    <p class="line-date">2025-02-28 </p>

    <div>
        <p class="line-title">
            <a href="/posts/golang/%E5%AE%9E%E7%8E%B0redis%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E5%88%86%E7%89%87/">
                实现redis客户端一致性哈希分片
            </a>
        </p>

        
        <p class="line-summary"> <h5 class="heading" id="实现原理">
  实现原理
  <a class="anchor" href="#%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86">#</a>
</h5>
<p>哈希方案有以下几种：</p>
<ul>
<li>普通哈希分片</li>
<li>一致性哈希分片</li>
<li>范围哈希分片</li>
</ul>
<p>分片有以下几种方案：</p>
<ul>
<li>redis官方哈希槽分片方案（属于服务端sharding，使用范围哈希）</li>
<li>客户端sharding，可以使用普通哈希、一致性哈希</li>
<li>代理sharding，使用代理器进行分片，有性能损耗</li>
</ul>
<h5 class="heading" id="客户端通过一致性哈希实现分片">
  客户端通过一致性哈希实现分片
  <a class="anchor" href="#%e5%ae%a2%e6%88%b7%e7%ab%af%e9%80%9a%e8%bf%87%e4%b8%80%e8%87%b4%e6%80%a7%e5%93%88%e5%b8%8c%e5%ae%9e%e7%8e%b0%e5%88%86%e7%89%87">#</a>
</h5>
<pre tabindex="0"><code>package main

import (
	&#34;context&#34;
	&#34;github.com/go-redis/redis/v8&#34;
	&#34;github.com/stathat/consistent&#34;
)

// 初始化支持一致性哈希的客户端结构
type ShardingClient struct {
	consistentHash *consistent.Consistent
	clients        map[string]*redis.Client
}

func NewShardingClient(addrs []string) *ShardingClient {
	ch := consistent.New()
	clients := make(map[string]*redis.Client)

	for _, addr := range addrs {
		ch.Add(addr)
		clients[addr] = redis.NewClient(&amp;redis.Options{
			Addr: addr,
		})
	}

	return &amp;ShardingClient{
		consistentHash: ch,
		clients:        clients,
	}
}

// getClient 根据键获取相应的 Redis 客户端
func (sc *ShardingClient) getClient(key string) (*redis.Client, error) {
	addr, err := sc.consistentHash.Get(key)
	if err != nil {
		return nil, err
	}
	return sc.clients[addr], nil
}

// Set 在相应的 Redis 实例上设置键值对
func (sc *ShardingClient) Set(ctx context.Context, key, value string) error {
	client, err := sc.getClient(key)
	if err != nil {
		return err
	}
	return client.Set(ctx, key, value, 0).Err()
}

// Get 在相应的 Redis 实例上获取键值对
func (sc *ShardingClient) Get(ctx context.Context, key string) (string, error) {
	client, err := sc.getClient(key)
	if err != nil {
		return &#34;&#34;, err
	}
	return client.Get(ctx, key).Result()
}


func main() {
	addrs := []string{
		&#34;127.0.0.1:6379&#34;,
		&#34;127.0.0.1:6380&#34;,
		&#34;127.0.0.1:6381&#34;,
	}

	// 初始化 Sharding 客户端
	shardingClient := NewShardingClient(addrs)

	ctx := context.Background()

	// 测试连接和操作
	err := shardingClient.Set(ctx, &#34;key&#34;, &#34;value&#34;)
	if err != nil {
		log.Fatalf(&#34;Failed to set key: %v&#34;, err)
	}

	val, err := shardingClient.Get(ctx, &#34;key&#34;)
	if err != nil {
		log.Fatalf(&#34;Failed to get key: %v&#34;, err)
	}

	fmt.Printf(&#34;key: %s\n&#34;, val)
}
</code></pre> </p>
        
    </div>
</div>
    

    

    
    <div class="post-line">

    
    
    
    

    <p class="line-date">2025-02-28 </p>

    <div>
        <p class="line-title">
            <a href="/posts/golang/go%E5%86%85%E5%AD%98%E6%B1%A0%E5%AE%9E%E7%8E%B0/">
                go内存池实现
            </a>
        </p>

        
        <p class="line-summary"> <h5 class="heading" id="实现">
  实现
  <a class="anchor" href="#%e5%ae%9e%e7%8e%b0">#</a>
</h5>
<p>用于管理固定大小的字节切片（<code>[]byte</code>）。内存池的目的在于减少内存分配和垃圾回收的开销，通过重用已经分配的内存块来提高性能</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="font-weight:bold;text-decoration:underline">package</span> main
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold;font-style:italic;text-decoration:underline">type</span> MemoryPool <span style="font-weight:bold;font-style:italic;text-decoration:underline">chan</span> []<span style="font-weight:bold;text-decoration:underline">byte</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic">// 从内存池中返回长度为8的字节切片，如果内存池中没有可用字节切片则新分配</span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold;font-style:italic;text-decoration:underline">func</span> (l MemoryPool) <span style="color:#666;font-weight:bold;font-style:italic">Borrow</span>() []<span style="font-weight:bold;text-decoration:underline">byte</span> {
</span></span><span style="display:flex;"><span>	<span style="font-weight:bold;font-style:italic;text-decoration:underline">var</span> buf []<span style="font-weight:bold;text-decoration:underline">byte</span>
</span></span><span style="display:flex;"><span>	<span style="font-weight:bold;text-decoration:underline">select</span> {
</span></span><span style="display:flex;"><span>	<span style="font-weight:bold;text-decoration:underline">case</span> buf = &lt;-l:
</span></span><span style="display:flex;"><span>	<span style="font-weight:bold;text-decoration:underline">default</span>:
</span></span><span style="display:flex;"><span>		buf = <span style="font-weight:bold;font-style:italic">make</span>([]<span style="font-weight:bold;text-decoration:underline">byte</span>, 8)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="font-weight:bold;text-decoration:underline">return</span> buf[:8]
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#888;font-style:italic">// 将字节切片放回内存池</span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold;font-style:italic;text-decoration:underline">func</span> (l MemoryPool) <span style="color:#666;font-weight:bold;font-style:italic">Return</span>(buf []<span style="font-weight:bold;text-decoration:underline">byte</span>) {
</span></span><span style="display:flex;"><span>	<span style="font-weight:bold;text-decoration:underline">select</span> {
</span></span><span style="display:flex;"><span>	<span style="font-weight:bold;text-decoration:underline">case</span> l &lt;- buf:
</span></span><span style="display:flex;"><span>	<span style="font-weight:bold;text-decoration:underline">default</span>:
</span></span><span style="display:flex;"><span>		<span style="color:#888;font-style:italic">// 垃圾回收</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold;font-style:italic;text-decoration:underline">func</span> <span style="color:#666;font-weight:bold;font-style:italic">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="font-weight:bold;font-style:italic;text-decoration:underline">var</span> mp MemoryPool = <span style="font-weight:bold;font-style:italic">make</span>(<span style="font-weight:bold;font-style:italic;text-decoration:underline">chan</span> []<span style="font-weight:bold;text-decoration:underline">byte</span>, 1024)
</span></span><span style="display:flex;"><span>	sl := mp.<span style="color:#666;font-weight:bold;font-style:italic">Borrow</span>()
</span></span><span style="display:flex;"><span>	mp.<span style="color:#666;font-weight:bold;font-style:italic">Return</span>(sl)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div> </p>
        
    </div>
</div>
    

    

    

</div>

    </main>
  </div>

  <footer>
    

    
    <p>Powered by
        <a href="https://gohugo.io/">Hugo</a>
        and
        <a href="https://github.com/tomfran/typo">tomfran/typo</a>
    </p>
    
    
    


  </footer>

  

</body>

<script src="/js/theme-switch.js"></script>
<script defer src="/js/copy-code.js"></script>
</html>
